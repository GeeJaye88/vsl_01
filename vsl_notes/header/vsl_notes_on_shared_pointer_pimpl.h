////////////////////////////////////////////////////////////////////////////////

// ---------- vsl_shared_pointer_pimpl.h ----------
/*!
\file vsl_shared_pointer_pimpl.h
\brief notes on shared pointers
\author Gareth Edwards
*/

#if _MSC_VER > 1000
#pragma once
#endif

////////////////////////////////////////////////////////////////////////////////

// ---- SHARED POINTER PIMPL

/*

	The deleter for a shared pointer is created here:

	Widget::Widget(): pImpl(new Impl) {}

	Until that point, all the shared pointer has is the equivalent
	of a std::funciton<VOID(Impl*)>.

	When you construct a shared_ptr with a T*, it writes a deleter
	and stores it in the std::function equivalent.

	At that point the type must be complete.

	So the only functions you have to define after Impl is fully
	defined are those that create a pImpl from a T* of some kind.

	Note: The unique_ptr<> template holds a pointer to an object
	and deletes this object when the unique_ptr<> object is deleted.

	So, in the example above, it does not matter if the function
	scope is left through the return statement, at the end of the
	function or even through an exception:

	The unique_ptr<> destructor is always called and therefore the
	object (int in the example) always deleted.

	Note: deleted when it goes out of scope.

	See: Herb Sutter’s Exceptional C++.
*/

/*

// ---- interface

class Widget
{
	public:
		Widget();
	private:
		struct Impl;
		std::shared_ptr<Impl> pImpl;
};

// ---- implementation

struct Widget::Impl
{
	std::string name;
};

Widget::Widget() : pImpl(new Impl) {}

*/


////////////////////////////////////////////////////////////////////////////////

// ---- LIST

/*

	// ---- D3D9 vertex buffer

	// ---- decleration

		struct I3D_Obj
		{
			I3D_Obj(std::string n, LPDIRECT3DVERTEXBUFFER9 vbs, INT np)
			{
				name = n;
				vb_source = vbs;
				num_prim = np;
			}
			std::string name;
			LPDIRECT3DVERTEXBUFFER9 vb_source = NULL;
			INT num_prim = 0;
		};
		std::list < I3D_Obj > ListOf_I3D_Obj;
	

	// ---- setup dx

		OutputDebugString("Create & Fill VertexBuffers\n");
		for (int i=0; i<6; i++)
		{
			char c[4];
			sprintf_s(c, 4, "%d", i);
			std::string name = c;
			ListOf_I3D_Obj.push_back(I3D_Obj(name, NULL, 0));
		}

		OutputDebugString("Created VertexBuffers:");
		std::list <I3D_Obj> ::iterator it;
		for (it = ListOf_I3D_Obj.begin(); it != ListOf_I3D_Obj.end(); it++)
		{
			OutputDebugString(" ");
			OutputDebugString(it->name.c_str());
		}
		OutputDebugString("\n");


	// ---- cleanup dx

		OutputDebugString("Release:");
		while (!ListOf_I3D_Obj.empty())
		{
			OutputDebugString(" ");
			OutputDebugString(ListOf_I3D_Obj.front().name.c_str());
			if (ListOf_I3D_Obj.front().vb_source != NULL)
			{
				INT new_ref_count = ListOf_I3D_Obj.front().vb_source->Release();
				// error new_ref_count...?
				// should not need - ListOf_I3D_Obj.front().vb_source = NULL;
			}
			ListOf_I3D_Obj.pop_front();
		}
		OutputDebugString("\n");

*/


////////////////////////////////////////////////////////////////////////////////


/*

INTERN STRING NOTES

Q: What is the difference between <string> & <string.h>

A: Those are two different headers.

	<string>   is for c++ std::string class
	<string.h> is for c string functions(like strlen(), etc.),
				which should be <cstring> for c++ project.

A: The C++ Standard Library also incorporates 18 headers of the ISO C90
	C standard library ending with ".h", but their use is deprecated.

	All other headers in the C++ Standard Library DO NOT end in ".h".

	Each header from the C Standard Library is included in the C++ Standard
	Library under a different name, generated by removing the .h, and adding
	a 'c' at the start; for example, 'time.h' becomes 'ctime'.

A: The difference is: <cstring> wraps everything in the std namespace
	whereas <string.h> puts everything in the global namespace.

	Also, expect some stricter type safety rules from <cstring>

*/
